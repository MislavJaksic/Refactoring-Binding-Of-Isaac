### First things first... play the game!

Before reading the code I wanted to get a feeling for the project scope: how many systems does it have, how
complex do they seem to be, how do they interact with the player and each other. As I couldn't find any project
documentation I decided to play the game and take notes on what I think is going on behind the scenes.
The notes I took are as follows:

Inputs: shoot and move; arrow keys and wasd.

The character can move in eight directions.
The character can shoot in four directions.
The character movement is blocked by walls.
The character moves randomly between rooms.
The character has health.
The character can pick up hearts and increase their health.
The character can take health damage.

A room has walls.
A room has doors.
A room can have enemies moving or shooting at the character.
A room can have moving obstacles.
A room's doors open when there are no enemies.

Enemies can move in all directions, even though walls.
Enemies can shoot in four directions.
Enemies have health, but the player cannot see it.
Enemies that touch the character deal health damage.
Enemies struck by the character's bullets take health damage.

After a few minutes, I've concluded that the Game is made out of Levels; Levels have Walls, Doors, Enemies and a Character;
the Enemies are quite diverse; the Character has a limited amount of health.

### Changing the morphology

After collapsing all the functions and deleting a few superfluous blank lines I've immediately noticed that the
JavaScript code is embedded in a HTML document. I'll remedy this by creating a "scripts" folder where I'll store all
the JavaScript code.

Now that the HTML and JavaScript files are in their separate folders, I'm going to place all the JavaScript variables
(and constants disguised as variables) at the top of the script, so I can get a better overview of what is going on.

Clean Code stresses the importance of carefully choosing variable names. Descriptive variable names can make
the code read as if it was written in a controlled language (see "Simple English") while poorly chosen names can
transform the program into an unsolvable puzzle. The first thing I'm going to do is change a few variable names:
abbreviations such as "ctx" will be renamed to "context"; short, names such as "x" will be replaced by a longer,
more descriptive name.

In addition, I'm going establish the following naming and style conventions:
* Local and global variables are made of lowercase words separated by underscores ("_").
* All other names are written in CamelCase: functions, methods, JavaScript "classes" and others.

* Indents are two whitespaces wide.
* Every statement ends with a ;.

For now, those conventions will be sufficient.

After replacing the names, I glanced at the event handlers. Each time the user presses or releases a key, the game
registers an event and performs the appropriate action. A total of eight key are tracked and are divided into two
groups of four keys: arrow keys for shooting and wasd for moving. This is how you control the game.

Now that variables and functions have been renamed, a few conventions have been established and I've identified
which functions deal with the input and which are responsible for drawing shapes, I'm ready analyse how the game is
implemented.

### Implementation analysis

The first function which the code invokes is Draw(). Looking at it, I can see that it does a lot; and at different
levels of abstraction (function, long, nested conditions and implementation statements, all weaved together).
Separating the implementation code and highly abstract functions is going to be my next order of business. After a
careful analysis, I have concluded that every time the <Canvas> element is redrawn the following happens in order:
<Canvas> is reset; something is done depending on the door_number; doors are drawn; the game check the victory and
defeat conditions; if bullets were fired, they should be drawn; walls, levels, the character, hearts and the score
is also drawn; a special bullet condition is checked; requestAnimationFrame() function is invoked; if any of the
shoot buttons are pressed, a bullet object is appended to the bullet array.

Now I'll take a look at the <Canvas> API and how the game is implemented at the lowest level of abstraction.

### Drawing API

 Canvas coordinate system:                      x
  ---------------------------------------------->
 | x=0, y=0
 |
 |
 |
 |
yV                x=canvas.width, y=canvas.height

[Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial):
* document.getElementById("myCanvas"); //-> grabs the <Canvas> from the HTML document
* canvas.getContext("2d"); //-> extracts the 2d context from the <Canvas>; drawing API is invoked thought it

[2D Canvas Context](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D):
* context.clearRect(x, y, width, height); //-> draw transparent black between the coordinates
* context.beginPath(); //-> begin a new path and clear all the older subpaths
* context.closePath(); //-> move the "pen" to the starting subpath coordinate and draw a line between the end and start points; either fill() or stroke()
* context.rect(x, y, width, height); //-> create a rectangle path for either stroke() or fill()
* context.arc(x, y, radius, startAngle, endAngle [, anticlockwise]); //-> start drawing from the x axis and continue clockwise; angles are expressed in radians, 90 degrees -> PI/2
* context.fill([fillRule]); //-> colour in everything "inside" the path (depending on the fill rule)
* context.stroke(); //-> draw the path

Now that I know what the game has to offer, how it is implemented and which technology it uses I can start
refactoring some of the functions.

### Refactoring; first attempt

